#include <stdio.h>
#include <stdlib.h>
#define WIDTH 7

//C Assignment 2 by Nia Touko. Written on 10/03/2024
//I interpreted the markscheme 1x1 inverse part as being able to correctly inverse a 1x1. If I was supposed to just throw an error, I can modify the program to accomplish this.

struct matrix{  //sets up the matrix structure as required in the brief
    int nrows;
    int ncols;
    float mValues[10][10]
};

void resetInputBuffer();     //this clears the input buffer, which allows the program to not error when a non-integer is passed in
int getUserInput(char* message, char* errorMessage, int uBound, int lBound);    //Gets user inputs for the row/column numbers in a sanitised way (any character can be entered and it won't error)
void matrixInput(struct matrix *mat, FILE *in);     //takes in inputs from the user on the dimensions of the matrix, and then reads numbers from the file to populate the matrix
void displayMatrix(struct matrix mat);  //Prints out the matrix in a human readable format via loops
float matrixDeterminant(struct matrix m1, struct matrix *m2, int *check);   //this function calculates a smaller 2x2 matrix from the main matrix (via getting user input) and then calculates its determinant. If the matrix passed in has one dimension less than 2, it forms a 1x1 matrix instead off user inputs, or automatically if a 1x1 matrix was passed in. The determinant is still calculated. If a 1x1 matrix was formed, it returns 1. If a 2x2 matrix with a non-zero determinant is formed, it returns 1. If the determinant is 0 it will return 2.
void matrixInverse(struct matrix m2, float determinant, struct matrix *m3); //finds the inverse of the matrix generated by matrixDeterminant() through iteration in line with the formula.

void main(){
    //Set up variables
    struct matrix mat;
    struct matrix mat2;
    struct matrix mat2Inv;

    int check;
    int error;

    //Set up files
    //finds file, if no file errors
    FILE *fin = fopen("matrix2.txt", "r"); // read only
    if (fin == NULL)
    {
        printf("Error, the file could not be found or accessed.\n");
        exit(-1);
    }

    char cont='1';
    //loops till break condition is met
    while(cont=='1'){
        //sets up big matrix
        matrixInput(&mat,fin);
        //displays
        printf("Here is your matrix:\n");
        displayMatrix(mat);
        //calculates the second matrix if the dimensions of the first are big enough

        printf("Creating either a 2x2 or 1x1 matrix from the original.\n");
        float det=matrixDeterminant(mat,&mat2,&check);
        printf("The determinant is %.2f for\n",det);
        displayMatrix(mat2);
        //calculates the inverse
        printf("Finding the inverse now!\n");
        if (check==1){  //if 2 by 2, call the function like normal
            matrixInverse(mat2,det,&mat2Inv);
            printf("Here is the inverse: \n");
            displayMatrix(mat2Inv);
        } else if(check==0){    //if 1x1, declare 1x1
            matrixInverse(mat2,det,&mat2Inv);
            printf("Here is the inverse of a 1x1 matrix: \n");
            displayMatrix(mat2Inv);
        }else{
            //Shows when inverse cannot be found.
            printf("Cannot find inverse. Determinant = 0.\n");
        }



        //checks if the code should end
        do{
        printf("Would you like to input another matrix? (type 1 for yes or type 0 for no): ");
        error=scanf("%s",&cont);
            if (cont!='1'&&cont!='0'||error!=1){
                printf("Invalid input.\n");
                resetInputBuffer();
            }
        } while(cont!='1'&&cont!='0');
        printf("\n");

    }

    fclose(fin);    //closes the file and exits the program, with a message
    printf("Exiting the program");

}


void resetInputBuffer(){
    int c;
    while ((c = getchar()) != '\n' && c != EOF);    //resets buffer
}

int getUserInput(char* message, char* errorMessage, int uBound, int lBound){
    int store;
    int error;
    do{
        printf("%s",message);   //prints the required question for the user input
        error=scanf("%d",&store);  //if non-integer passed in, returns not 1
        if (store>uBound||store<lBound||error!=1){  //checks that the input is valid, otherwise displays error message
            printf("%s",errorMessage);
            resetInputBuffer(); //resets the buffer to prevent infinite looping
        }

    } while(store>uBound||store<lBound||error!=1);  //loops till valid input is declared
    return store;
}

void matrixInput(struct matrix *mat, FILE *in){
    int error;
    fseek(in,0,SEEK_SET); //resets file pointer
    printf("For the following questions, enter a number between 1 and 10.\n");

    //gets the rows and columns from the user
    mat->nrows=getUserInput("How many rows would you like? ","Enter a number between 1 and 10.\n",10,1);
    mat->ncols=getUserInput("How many columns would you like? ","Enter a number between 1 and 10.\n",10,1);


    //reads in the data from the file and stores it in the matrix
    for (int i = 0; i < mat->nrows; i++) {
        for (int j = 0; j < mat->ncols; j++) {
            fscanf(in, "%f", &mat->mValues[i][j]);
        }
    }
}

void displayMatrix(struct matrix mat){

    //Prints the matrix, with each character a given width.
    for (int i = 0; i < mat.nrows; i++) {
        printf("|");
        for (int j = 0; j < mat.ncols; j++) {
            printf("%*.2f ",WIDTH, mat.mValues[i][j]);
        }
        printf("|");
        printf("\n");
    }
}

float matrixDeterminant(struct matrix m1, struct matrix *m2, int *check){
    int rowNum;
    int colNum;
    float det;
    char message[100];
    if (m1.ncols>1 && m1.nrows>1){ //checks if the matrix can form a 2x2
        m2->nrows=2;    //sets it to 2x2
        m2->ncols=2;

        if (m1.nrows-2>0){
            sprintf(message,"What row would you like to store from. Enter between 0 and %d: ",(m1.nrows-2));    //creates the message outputted to the user
            rowNum=getUserInput(message,"Invalid input.\n",m1.nrows-2,0);   //gets the row number
        } else{
            rowNum=0;
        }
        if (m1.ncols-2>0){
            sprintf(message,"What column would you like to store from. Enter between 0 and %d: ",(m1.ncols-2));    //same but for the column.
            colNum=getUserInput(message,"Invalid input.\n",m1.ncols-2,0);
        } else{
            colNum=0;
        }

        for (int i = 0; i < m2->nrows; i++) {
            for (int j = 0; j < m2->ncols; j++) {
                m2->mValues[i][j] = m1.mValues[rowNum+i][colNum+j];     //this loops through the 2x2 matrix, ands each value in turn to it
            }
        }
        det = (m2->mValues[0][0] * m2->mValues[1][1]) - (m2->mValues[0][1] * m2->mValues[1][0]);  //if 2x2, return the determinant from the formula for a 2x2 determinant
    }
    else{
        //If a matrix with dimensions smaller than 2 is selected in the previous section, then select only the first value and stores it as a 1x1.
        m2->nrows=1;    //sets it to 1x1
        m2->ncols=1;
        if (m1.nrows>1){    //if this is not 1, ask the user what row, otherwise, pick the only row avalable
            sprintf(message,"What row would you like to store from. Enter between 0 and %d: ",(m1.nrows-1));    //creates the message outputted to the user
            rowNum=getUserInput(message,"Invalid input.\n",m1.nrows-1,0);   //gets the row number
        }
        else{
            rowNum=0;   //sets it to the only available row if its all that is available.
        }

        if (m1.ncols>1){
                sprintf(message,"What column would you like to store from. Enter between 0 and %d: ",(m1.ncols-1));    //same but for the column.
                colNum=getUserInput(message,"Invalid input.\n",m1.ncols-1,0);
        }else{
            colNum=0;
        }

        m2->mValues[0][0],det=m1.mValues[rowNum][colNum];   //stores the value in a 1x1 matrix, then finds the determinant
    }
    if (det == 0) {    //if the matrix has a determinant of 0, it is singular and does not have an inverse. This is flagged so matrixInverse() is not called on it. This is before the dimension check to stop errors on a 1x1 matrix with a 0 determinant.
        *check = 2;
    }
    else if (m2->nrows!=2){  //if a 1x1 matrix, then return the determinant. Only need to check one as m2 will always be a square matrix.
        *check=0;
    }
    else{       //else, the matrix is both 2x2 and is non-singular
        *check = 1;
    }
    return det;
}

void matrixInverse(struct matrix m2, float determinant, struct matrix *m3){

    if (m2.nrows==1){   //checks if it is 2x2 or 1x1. Since only square matrices will be passed in, only needs one check
        m3->nrows=1;    //sets it to 1x1
        m3->ncols=1;
        m3->mValues[0][0] = 1/determinant;  //Inverts it according to the inverse of a 1x1 matrix
    }else{
        m3->nrows=2;    //sets it to 2x2
        m3->ncols=2;
        for (int i = 0; i < m3->nrows; i++) {
            for (int j = 0; j < m3->ncols; j++) {
                if (i==j){
                    m3->mValues[i][j] = m2.mValues[1-j][1-i]/determinant;   //iterates and preforms an inverse of the matrix. this swaps them across the diagonal and applies the formula with the determinatn
                }
                else{
                    m3->mValues[i][j] = -m2.mValues[i][j]/determinant;      //this line negatives the values and applies the formula with the determinatn
                }
                if (m3->mValues[i][j]==-0){ //Prevents negative 0 from being stored in the matrix for readability and accuracy,
                    m3->mValues[i][j]=0;
                }
            }
        }
    }
}
